// Automatically generated by wrapgen.
// Source: #! .Source !#
package mocks

import (
	gomock "github.com/golang/mock"
	"#! .Source !#"
	#! range .Package.Imports !##! .Package !# "#! .Path !#"
	#! end !#
)

#! $pkgName := .Package.Name !##! range .Package.Interfaces !#
// Mock of #! .Name !# interface
type Mock#! .Name !# struct {
	ctrl *gomock.Controller
	recorder *_Mock#! .Name !#Recorder
}

// Recorder for Mock#! .Name !# (not exported)
type _Mock#! .Name !#Recorder struct{
	mock *Mock#! .Name !#
}

func NewMock#! .Name !#(ctrl *gomock.Controller) *Mock#! .Name !# {
	var mock = &Mock#! .Name !#{ctrl: ctrl}
	mock.recorder = &_Mock#! .Name !#Recorder{mock}
	return mock
}

func (_m *Mock#! .Name !#) EXPECT() *_Mock#! .Name !#Recorder {
	return _m.recorder
}

#! $ifaceRef := . !##! range .Methods !#

func (_m *Mock#! $ifaceRef.Name !#) #! .Name !#(#! $methodRef := . !##! range $x, $e := .In !##! $e.Name !# #! $e.Type !##! if ne $x (add (len $methodRef.In) -1)!#, #! end !##! end !#) (#! $methodRef := . !##! range $x, $e := .Out !##! $e.Type !##! if ne $x (add (len $methodRef.Out) -1)!#, #! end !##! end !#) {
	var _s = []interface{}{#! range $x, $e := .In !##! if lt $x (add (len $methodRef.In) -1) !##! $e.Name !##! if lt $x (add (len $methodRef.In) -2) !#,#! end !##! end !##! end !#}
	#! if gt (len .In) 0 !#_s = append(_s, #! if contains "..." (index .In (add (len .In) -1)).Type.String !##! (index .In (add (len .In) -1)).Name !#...#! else !##! (index .In (add (len .In) -1)).Name !##! end !#)#! end !#
	#! if eq (len .Out) 0 !#_m.ctrl.Call("#! .Name !#", _s...)
	#! else !# var ret = _m.ctrl.Call("#! .Name !#", _s...)
	#! range $x, $e := .Out !##! $e.Name !#, _ := ret[#! $x !#].(#! $e.Type !#)
	#! end !#
	return #! range $x, $e := .Out !##! $e.Name !##! if ne $x (add (len $methodRef.Out) -1) !#,#! end !##! end !#
	#! end !#
}

func (_mr *_Mock#! $ifaceRef.Name !#Recorder) #! .Name !#(#! $methodRef := . !##! range $x, $e := .In !##! if ne $x (add (len $methodRef.In) -1) !##! $e.Name!# interface{},#! else if contains "..." $e.Type.String !##! $e.Name !# ...interface{}#! else !##! $e.Name !# interface{}#! end !##! end !#) *gomock.Call {
	var _s = []interface{}{#! range $x, $e := .In !##! if lt $x (add (len $methodRef.In) -1) !##! $e.Name !##! if lt $x (add (len $methodRef.In) -2) !#,#! end !##! end !##! end !#}
	#! if gt (len .In) 0 !#_s = append(_s, #! if contains "..." (index .In (add (len .In) -1)).Type.String !##! (index .In (add (len .In) -1)).Name !#...#! else !##! (index .In (add (len .In) -1)).Name !##! end !#)#! end !#
	return _mr.mock.ctrl.RecordCall(_mr.mock, "#! .Name !#", _s...)
}

#! end !#
#! end !#
